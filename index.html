<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO11 Real-time Object Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 5px;
            font-size: 28px;
            text-align: center;
        }
        
        .model-badge {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 25px;
            font-size: 14px;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        #video {
            width: 100%;
            display: block;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
          
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .status-text {
            color: #333;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-label {
            color: #666;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #333;
            font-size: 24px;
            font-weight: 700;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: none;
        }
        
        .settings {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .setting-row:last-child {
            margin-bottom: 0;
        }
        
        .setting-label {
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .slider-value {
            color: #667eea;
            font-weight: 700;
            min-width: 50px;
            text-align: right;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            input[type="range"] {
                width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ YOLO11 Object Detection</h1>
        <div class="model-badge">
            <span class="badge">YOLO11n - Nano Model (2.6M params)</span>
        </div>
        <p class="subtitle">State-of-the-art real-time object detection powered by ONNX Runtime</p>
        
        <div class="status">
            <div class="status-text" id="statusText">Click "Start Detection" to begin</div>
        </div>
        
        <div class="settings">
            <div class="setting-row">
                <span class="setting-label">Confidence Threshold:</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="confThreshold" min="0.1" max="1" step="0.05" value="0.5">
                    <span class="slider-value" id="confValue">0.50</span>
                </div>
            </div>
            <div class="setting-row">
                <span class="setting-label">IoU Threshold:</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="iouThreshold" min="0.1" max="1" step="0.05" value="0.45">
                    <span class="slider-value" id="iouValue">0.45</span>
                </div>
            </div>
        </div>
        
        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="startBtn">Start Detection</button>
            <button id="stopBtn" disabled>Stop Detection</button>
            <button id="switchBtn" disabled>Switch Camera</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Objects Detected</div>
                <div class="stat-value" id="objectCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">FPS</div>
                <div class="stat-value" id="fps">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Inference Time</div>
                <div class="stat-value" id="inferenceTime">0ms</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Model Status</div>
                <div class="stat-value" id="modelStatus" style="font-size: 16px;">Not Loaded</div>
            </div>
        </div>
        
        <div class="error" id="errorMsg"></div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const switchBtn = document.getElementById('switchBtn');
        const statusText = document.getElementById('statusText');
        const objectCount = document.getElementById('objectCount');
        const fpsDisplay = document.getElementById('fps');
        const inferenceTimeDisplay = document.getElementById('inferenceTime');
        const modelStatus = document.getElementById('modelStatus');
        const errorMsg = document.getElementById('errorMsg');
        const confThreshold = document.getElementById('confThreshold');
        const iouThreshold = document.getElementById('iouThreshold');
        const confValue = document.getElementById('confValue');
        const iouValue = document.getElementById('iouValue');

        let session = null;
        let stream = null;
        let animationId = null;
        let currentCamera = 'environment';
        let isDetecting = false;
        
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let fpsValue = 0;
        
        const MODEL_URL = 'https://huggingface.co/giangndm/yolo11-onnx/resolve/main/yolo11s_640.onnx?download=true'; //'https://huggingface.co/nomi30701/yolo11n/resolve/main/yolo11n.onnx';
        const INPUT_SIZE = 640;
        
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788',
            '#FF6B9D', '#C9ADA7', '#4A90E2', '#E07A5F', '#81B29A'
        ];
        
        const classNames = ["person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat", "traffic light", "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep", "cow", "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella", "handbag", "tie", "suitcase", "frisbee", "skis", "snowboard", "sports ball", "kite", "baseball bat", "baseball glove", "skateboard", "surfboard", "tennis racket", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple", "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair", "couch", "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse", "remote", "keyboard", "cell phone", "microwave", "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear", "hair drier", "toothbrush"];

        confThreshold.addEventListener('input', (e) => {
            confValue.textContent = parseFloat(e.target.value).toFixed(2);
        });
        
        iouThreshold.addEventListener('input', (e) => {
            iouValue.textContent = parseFloat(e.target.value).toFixed(2);
        });

        async function loadModel() {
            try {
                statusText.innerHTML = 'Loading YOLO11 model...<span class="loading"></span>';
                modelStatus.textContent = 'Loading...';

                const modelBuffer = await fetchWithCache(MODEL_URL);
                
                session = await ort.InferenceSession.create(modelBuffer, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                    enableOrtIoBinding: true
                });
                
                statusText.textContent = 'YOLO11 model loaded successfully! Ready to detect 80 object classes.';
                modelStatus.textContent = 'âœ“ Ready';
                modelStatus.style.color = '#52B788';
                return true;
            } catch (error) {
                showError('Failed to load YOLO11 model: ' + error.message);
                modelStatus.textContent = 'âœ— Failed';
                modelStatus.style.color = '#c33';
                return false;
            }
        }

        async function setupCamera() {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        facingMode: currentCamera,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
            } catch (error) {
                showError('Camera access denied: ' + error.message);
                throw error;
            }
        }

        function preprocessImage() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = INPUT_SIZE;
            tempCanvas.height = INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(video, 0, 0, INPUT_SIZE, INPUT_SIZE);
            const imageData = tempCtx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            
            const input = new Float32Array(3 * INPUT_SIZE * INPUT_SIZE);
            const pixels = imageData.data;
            
            for (let i = 0; i < INPUT_SIZE * INPUT_SIZE; i++) {
                input[i] = pixels[i * 4] / 255.0;
                input[INPUT_SIZE * INPUT_SIZE + i] = pixels[i * 4 + 1] / 255.0;
                input[2 * INPUT_SIZE * INPUT_SIZE + i] = pixels[i * 4 + 2] / 255.0;
            }
            
            return input;
        }

        function nonMaxSuppression(boxes, confThresh, iouThresh) {
            const result = [];
            const sorted = boxes.sort((a, b) => b.confidence - a.confidence);
            
            while (sorted.length > 0) {
                const best = sorted.shift();
                result.push(best);
                
                for (let i = sorted.length - 1; i >= 0; i--) {
                    const iou = calculateIoU(best, sorted[i]);
                    if (iou > iouThresh) {
                        sorted.splice(i, 1);
                    }
                }
            }
            
            return result.filter(box => box.confidence >= confThresh);
        }

        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.w, box2.x + box2.w);
            const y2 = Math.min(box1.y + box1.h, box2.y + box2.h);
            
            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = box1.w * box1.h;
            const area2 = box2.w * box2.h;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }

        function postprocess(output) {
            const boxes = [];
            const [batchSize, channels, numDetections] = output.dims;
            const data = output.data;
            
            const scaleX = canvas.width / INPUT_SIZE;
            const scaleY = canvas.height / INPUT_SIZE;
            
            for (let i = 0; i < numDetections; i++) {
                const scores = [];
                for (let j = 4; j < channels; j++) {
                    scores.push(data[j * numDetections + i]);
                }
                
                const maxScore = Math.max(...scores);
                const classId = scores.indexOf(maxScore);
                
                if (maxScore > parseFloat(confThreshold.value)) {
                    const cx = data[0 * numDetections + i] * scaleX;
                    const cy = data[1 * numDetections + i] * scaleY;
                    const w = data[2 * numDetections + i] * scaleX;
                    const h = data[3 * numDetections + i] * scaleY;
                    
                    boxes.push({
                        x: cx - w / 2,
                        y: cy - h / 2,
                        w: w,
                        h: h,
                        confidence: maxScore,
                        class: classId,
                        className: classNames[classId]
                    });
                }
            }
            
            return nonMaxSuppression(boxes, parseFloat(confThreshold.value), parseFloat(iouThreshold.value));
        }

        async function detectObjects() {
            if (!isDetecting || !session) return;

            try {
                const startTime = performance.now();
                
                const input = preprocessImage();
                const tensor = new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
                const feeds = { images: tensor };
                const results = await session.run(feeds);
                const output = results.output0;
                
                const inferenceTime = Math.round(performance.now() - startTime);
                inferenceTimeDisplay.textContent = inferenceTime + 'ms';
                
                const detections = postprocess(output);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                objectCount.textContent = detections.length;
                
                detections.forEach((det, index) => {
    const color = colors[index % colors.length];

    // ðŸ” Mirror X to match the flipped video
    const drawX = canvas.width - det.x - det.w;
    const drawY = det.y;

    // Box
    ctx.strokeStyle = color;
    ctx.lineWidth = 6;
    ctx.strokeRect(drawX, drawY, det.w, det.h);

    // Label
    const label = `${det.className} ${Math.round(det.confidence * 100)}%`;
    ctx.font = 'bold 20px Arial';
    const textWidth = ctx.measureText(label).width;

    ctx.fillStyle = color;
    ctx.fillRect(drawX, drawY - 25, textWidth + 10, 25);

    ctx.fillStyle = '#fff';
    ctx.fillText(label, drawX + 5, drawY - 7);

    // Fancy corners â€“ all use drawX instead of det.x
    const cornerLen = 15;
    ctx.lineWidth = 6;

    // top-left
    ctx.beginPath();
    ctx.moveTo(drawX, drawY + cornerLen);
    ctx.lineTo(drawX, drawY);
    ctx.lineTo(drawX + cornerLen, drawY);
    ctx.stroke();

    // top-right
    ctx.beginPath();
    ctx.moveTo(drawX + det.w - cornerLen, drawY);
    ctx.lineTo(drawX + det.w, drawY);
    ctx.lineTo(drawX + det.w, drawY + cornerLen);
    ctx.stroke();

    // bottom-left
    ctx.beginPath();
    ctx.moveTo(drawX, drawY + det.h - cornerLen);
    ctx.lineTo(drawX, drawY + det.h);
    ctx.lineTo(drawX + cornerLen, drawY + det.h);
    ctx.stroke();

    // bottom-right
    ctx.beginPath();
    ctx.moveTo(drawX + det.w - cornerLen, drawY + det.h);
    ctx.lineTo(drawX + det.w, drawY + det.h);
    ctx.lineTo(drawX + det.w, drawY + det.h - cornerLen);
    ctx.stroke();
});

                
                frameCount++;
                const now = Date.now();
                if (now - lastFrameTime >= 1000) {
                    fpsValue = frameCount;
                    fpsDisplay.textContent = fpsValue;
                    frameCount = 0;
                    lastFrameTime = now;
                }
                
                animationId = requestAnimationFrame(detectObjects);
            } catch (error) {
                console.error('Detection error:', error);
                showError('Detection error: ' + error.message);
            }
        }

        async function startDetection() {
            try {
                startBtn.disabled = true;
                
                if (!session) {
                    const loaded = await loadModel();
                    if (!loaded) {
                        startBtn.disabled = false;
                        return;
                    }
                }

                statusText.textContent = 'Starting camera...';
                await setupCamera();

                isDetecting = true;
                statusText.textContent = 'ðŸŽ¥ Detecting objects in real-time with YOLO11...';
                stopBtn.disabled = false;
                switchBtn.disabled = false;
                
                detectObjects();
            } catch (error) {
                startBtn.disabled = false;
                showError('Failed to start: ' + error.message);
            }
        }

        function stopDetection() {
            isDetecting = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            switchBtn.disabled = true;
            statusText.textContent = 'Detection stopped. Click "Start Detection" to resume.';
            objectCount.textContent = '0';
            fpsDisplay.textContent = '0';
            inferenceTimeDisplay.textContent = '0ms';
        }

        async function switchCamera() {
            currentCamera = currentCamera === 'user' ? 'environment' : 'user';
            
            if (isDetecting) {
                stopBtn.disabled = true;
                switchBtn.disabled = true;
                statusText.textContent = 'Switching camera...';
                
                await setupCamera();
                
                stopBtn.disabled = false;
                switchBtn.disabled = false;
                statusText.textContent = 'ðŸŽ¥ Detecting objects in real-time with YOLO11...';
            }
        }

        function showError(message) {
            errorMsg.textContent = 'âš ï¸ ' + message;
            errorMsg.style.display = 'block';
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, 5000);
        }

        async function fetchWithCache(url, cacheName = "yolo-model-cache") {
            const cache = await caches.open(cacheName);
            const cached = await cache.match(url);
        
            if (cached) {
                console.log("Loaded model from cache");
                return cached.arrayBuffer();
            }
        
            const response = await fetch(url);
            const buffer = await response.arrayBuffer();
        
            await cache.put(url, new Response(buffer));
            console.log("Model cached for future use");
        
            return buffer;
        }


        startBtn.addEventListener('click', startDetection);
        stopBtn.addEventListener('click', stopDetection);
        switchBtn.addEventListener('click', switchCamera);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isDetecting) {
                stopDetection();
            }
        });

        window.addEventListener('load', () => {
            statusText.textContent = 'Ready! Click "Start Detection" to load YOLO11 and begin.';
        });


        
    </script>
</body>
</html>
